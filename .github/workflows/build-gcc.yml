name: Build GCC from Source

on:
  workflow_dispatch:
    inputs:
      version:
        description: 'GCC Version to build'
        required: true
        default: '15'
        type: choice
        options:
          - '15'
          - '14'
          - '13'
          - '12'
      branch:
        description: 'Branch to checkout for workflow'
        required: false
        default: 'main'
        type: string

env:
  # Version mappings - will be used to get exact versions
  GCC_15_VERSION: '15.1.0'
  GCC_14_VERSION: '14.3.0'
  GCC_13_VERSION: '13.3.0'
  GCC_12_VERSION: '12.4.0'
  
  # Dependency versions for static compilation
  GMP_VERSION: '6.3.0'
  MPFR_VERSION: '4.2.1'
  MPC_VERSION: '1.3.1'
  ISL_VERSION: '0.26'

jobs:
  get-version:
    runs-on: ubuntu-latest
    outputs:
      exact_version: ${{ steps.set-version.outputs.exact_version }}
      major_version: ${{ steps.set-version.outputs.major_version }}
    steps:
      - name: Set exact version
        id: set-version
        run: |
          case "${{ github.event.inputs.version }}" in
            "15")
              echo "exact_version=${{ env.GCC_15_VERSION }}" >> $GITHUB_OUTPUT
              echo "major_version=15" >> $GITHUB_OUTPUT
              ;;
            "14")
              echo "exact_version=${{ env.GCC_14_VERSION }}" >> $GITHUB_OUTPUT
              echo "major_version=14" >> $GITHUB_OUTPUT
              ;;
            "13")
              echo "exact_version=${{ env.GCC_13_VERSION }}" >> $GITHUB_OUTPUT
              echo "major_version=13" >> $GITHUB_OUTPUT
              ;;
            "12")
              echo "exact_version=${{ env.GCC_12_VERSION }}" >> $GITHUB_OUTPUT
              echo "major_version=12" >> $GITHUB_OUTPUT
              ;;
            *)
              echo "Unsupported version: ${{ github.event.inputs.version }}"
              exit 1
              ;;
          esac

  build-gcc:
    needs: get-version
    timeout-minutes: 180
    strategy:
      matrix:
        include:
          - arch: x86_64
            runner: ubuntu-22.04
          - arch: aarch64
            runner: ubuntu-22.04-arm
    runs-on: ${{ matrix.runner }}
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          ref: ${{ github.event.inputs.branch }}

      - name: Set up build environment
        run: |
          sudo apt-get update
          sudo apt-get install -y \
            build-essential \
            zlib1g-dev \
            wget \
            tar \
            xz-utils \
            flex \
            bison \
            texinfo
          
          # Verify static zlib library is available
          ls -la /usr/lib/*/libz.a || echo "Static zlib not found in expected location"
          find /usr -name "libz.a" 2>/dev/null || echo "Static zlib library not found"

      # No cross-compilation tools needed - using native ARM64 runner for aarch64

      - name: Build GCC dependencies from source
        run: |
          echo "=== Building GCC dependencies from source for static linking ==="
          
          # Create a local prefix for our dependencies
          export DEPS_PREFIX="$PWD/gcc-deps"
          mkdir -p "$DEPS_PREFIX"
          
          # Set up build environment for static libraries
          export CFLAGS="-O2 -fPIC"
          export CXXFLAGS="-O2 -fPIC"
          export LDFLAGS="-static"
          
          echo "Building dependencies in order: GMP → MPFR → MPC → ISL"
          
          # Build GMP (base dependency)
          echo "=== Building GMP ${{ env.GMP_VERSION }} ==="
          wget -q https://mirror.csclub.uwaterloo.ca/gnu/gmp/gmp-${{ env.GMP_VERSION }}.tar.xz || \
          wget -q https://mirrors.kernel.org/gnu/gmp/gmp-${{ env.GMP_VERSION }}.tar.xz || \
          wget -q https://ftp.gnu.org/gnu/gmp/gmp-${{ env.GMP_VERSION }}.tar.xz || \
          wget -q https://gmplib.org/download/gmp/gmp-${{ env.GMP_VERSION }}.tar.xz
          tar -xf gmp-${{ env.GMP_VERSION }}.tar.xz
          cd gmp-${{ env.GMP_VERSION }}
          ./configure --prefix="$DEPS_PREFIX" --enable-static --disable-shared --enable-cxx
          make -j$(nproc)
          make install
          cd ..
          
          # Build MPFR (depends on GMP)
          echo "=== Building MPFR ${{ env.MPFR_VERSION }} ==="
          wget -q https://mirror.csclub.uwaterloo.ca/gnu/mpfr/mpfr-${{ env.MPFR_VERSION }}.tar.xz || \
          wget -q https://mirrors.kernel.org/gnu/mpfr/mpfr-${{ env.MPFR_VERSION }}.tar.xz || \
          wget -q https://ftp.gnu.org/gnu/mpfr/mpfr-${{ env.MPFR_VERSION }}.tar.xz || \
          wget -q https://www.mpfr.org/mpfr-current/mpfr-${{ env.MPFR_VERSION }}.tar.xz
          tar -xf mpfr-${{ env.MPFR_VERSION }}.tar.xz
          cd mpfr-${{ env.MPFR_VERSION }}
          ./configure --prefix="$DEPS_PREFIX" --enable-static --disable-shared --with-gmp="$DEPS_PREFIX"
          make -j$(nproc)
          make install
          cd ..
          
          # Build MPC (depends on GMP and MPFR)
          echo "=== Building MPC ${{ env.MPC_VERSION }} ==="
          wget -q https://mirror.csclub.uwaterloo.ca/gnu/mpc/mpc-${{ env.MPC_VERSION }}.tar.gz || \
          wget -q https://mirrors.kernel.org/gnu/mpc/mpc-${{ env.MPC_VERSION }}.tar.gz || \
          wget -q https://ftp.gnu.org/gnu/mpc/mpc-${{ env.MPC_VERSION }}.tar.gz
          tar -xf mpc-${{ env.MPC_VERSION }}.tar.gz
          cd mpc-${{ env.MPC_VERSION }}
          ./configure --prefix="$DEPS_PREFIX" --enable-static --disable-shared --with-gmp="$DEPS_PREFIX" --with-mpfr="$DEPS_PREFIX"
          make -j$(nproc)
          make install
          cd ..
          
          # Build ISL (depends on GMP)
          echo "=== Building ISL ${{ env.ISL_VERSION }} ==="
          wget -q https://mirror.csclub.uwaterloo.ca/gnu/gcc/infrastructure/isl-${{ env.ISL_VERSION }}.tar.bz2 || \
          wget -q https://mirrors.kernel.org/gnu/gcc/infrastructure/isl-${{ env.ISL_VERSION }}.tar.bz2 || \
          wget -q https://gcc.gnu.org/pub/gcc/infrastructure/isl-${{ env.ISL_VERSION }}.tar.bz2 || \
          wget -q https://libisl.sourceforge.io/isl-${{ env.ISL_VERSION }}.tar.bz2
          tar -xf isl-${{ env.ISL_VERSION }}.tar.bz2
          cd isl-${{ env.ISL_VERSION }}
          ./configure --prefix="$DEPS_PREFIX" --enable-static --disable-shared --with-gmp="$DEPS_PREFIX"
          make -j$(nproc)
          make install
          cd ..
          
          # Verify all libraries are built
          echo "=== Verifying built libraries ==="
          ls -la "$DEPS_PREFIX/lib/"
          echo "Static libraries found:"
          find "$DEPS_PREFIX/lib" -name "*.a" | sort
          
          # Verify pkg-config files
          echo "pkg-config files:"
          find "$DEPS_PREFIX/lib/pkgconfig" -name "*.pc" | sort || echo "No pkg-config files found"

      - name: Download GCC source
        run: |
          # Try multiple mirrors for reliability
          wget -q https://mirror.csclub.uwaterloo.ca/gnu/gcc/gcc-${{ needs.get-version.outputs.exact_version }}/gcc-${{ needs.get-version.outputs.exact_version }}.tar.xz || \
          wget -q https://mirrors.kernel.org/gnu/gcc/gcc-${{ needs.get-version.outputs.exact_version }}/gcc-${{ needs.get-version.outputs.exact_version }}.tar.xz || \
          wget -q https://ftp.gnu.org/gnu/gcc/gcc-${{ needs.get-version.outputs.exact_version }}/gcc-${{ needs.get-version.outputs.exact_version }}.tar.xz
          tar -xf gcc-${{ needs.get-version.outputs.exact_version }}.tar.xz

      - name: Configure build
        run: |
          mkdir -p build-gcc-${{ matrix.arch }}
          cd build-gcc-${{ matrix.arch }}
          
          # Set up paths for our locally built dependencies
          export DEPS_PREFIX="$PWD/../gcc-deps"
          export PKG_CONFIG_PATH="$DEPS_PREFIX/lib/pkgconfig:$PKG_CONFIG_PATH"
          export LD_LIBRARY_PATH="$DEPS_PREFIX/lib:$LD_LIBRARY_PATH"
          
          # Native build configuration for both architectures
          # Use optimized flags without debug info to reduce binary size
          # Build static binaries to eliminate glibc runtime dependencies
          # Point to our locally built static dependencies
          CFLAGS="-O2" CXXFLAGS="-O2" \
          LDFLAGS="-static -L$DEPS_PREFIX/lib" \
          CPPFLAGS="-I$DEPS_PREFIX/include" \
          LIBS="-lz" \
          ../gcc-${{ needs.get-version.outputs.exact_version }}/configure \
            --prefix=/opt/gcc-${{ needs.get-version.outputs.exact_version }}-${{ matrix.arch }} \
            --enable-languages=c,c++,fortran \
            --disable-multilib \
            --enable-threads=posix \
            --disable-shared \
            --enable-static \
            --with-system-zlib \
            --with-gmp="$DEPS_PREFIX" \
            --with-mpfr="$DEPS_PREFIX" \
            --with-mpc="$DEPS_PREFIX" \
            --with-isl="$DEPS_PREFIX" \
            --disable-bootstrap

      - name: Build GCC
        run: |
          cd build-gcc-${{ matrix.arch }}
          make -j$(nproc)

      - name: Install GCC
        run: |
          cd build-gcc-${{ matrix.arch }}
          sudo make install-strip DESTDIR=$PWD/install-root

      - name: Create glibc sysroot package
        run: |
          echo "=== Creating glibc sysroot package ==="
          
          # Create sysroot directory structure
          SYSROOT_DIR="glibc-sysroot-${{ matrix.arch }}"
          mkdir -p "$SYSROOT_DIR"/{lib,lib64,usr/{lib,include}}
          
          # Get the system's multiarch directory
          MULTIARCH_DIR=$(gcc -print-multiarch 2>/dev/null || echo "$(uname -m)-linux-gnu")
          SYSTEM_LIB_DIR="/usr/lib/$MULTIARCH_DIR"
          
          echo "Building glibc sysroot for ${{ matrix.arch }}"
          echo "System multiarch directory: $MULTIARCH_DIR"
          echo "System lib directory: $SYSTEM_LIB_DIR"
          
          # Copy C runtime startup files (crt*.o)
          echo "Copying C runtime startup files..."
          if [ -d "$SYSTEM_LIB_DIR" ]; then
            find "$SYSTEM_LIB_DIR" -name "crt*.o" -exec cp {} "$SYSROOT_DIR/lib/" \; 2>/dev/null || true
            find /usr/lib -name "crt*.o" -exec cp {} "$SYSROOT_DIR/lib/" \; 2>/dev/null || true
          fi
          
          # Copy essential glibc libraries (both static and dynamic with all versions)
          echo "Copying glibc libraries..."
          
          # Core glibc shared libraries - copy all versions and symlinks
          for lib_pattern in "libc.so*" "libm.so*" "libpthread.so*" "libdl.so*" "libresolv.so*" "librt.so*" "libutil.so*"; do
            find /lib /usr/lib "$SYSTEM_LIB_DIR" -name "$lib_pattern" -exec cp -P {} "$SYSROOT_DIR/lib/" \; 2>/dev/null || true
          done
          
          # Additional essential shared libraries
          for lib_pattern in "libcrypt.so*" "libnss_*.so*" "libBrokenLocale.so*" "libanl.so*" "libmvec.so*"; do
            find /lib /usr/lib "$SYSTEM_LIB_DIR" -name "$lib_pattern" -exec cp -P {} "$SYSROOT_DIR/lib/" \; 2>/dev/null || true
          done
          
          # Copy static libraries (including version-specific ones)
          echo "Copying static libraries..."
          for lib_pattern in "libc.a" "libc-*.a" "libc_nonshared.a" "libm.a" "libm-*.a" "libmvec.a" \
                             "libpthread.a" "libdl.a" "libresolv.a" "librt.a" "libutil.a" \
                             "libcrypt.a" "libnss_*.a" "libBrokenLocale.a" "libanl.a"; do
            find /usr/lib "$SYSTEM_LIB_DIR" -name "$lib_pattern" -exec cp {} "$SYSROOT_DIR/lib/" \; 2>/dev/null || true
          done
          
          # Copy architecture-specific libraries that may not be found by general patterns
          echo "Copying architecture-specific libraries..."
          
          # Try to find libmvec more aggressively (seems to be missing on aarch64)
          find /usr/lib /lib "$SYSTEM_LIB_DIR" -name "libmvec*" -exec cp -P {} "$SYSROOT_DIR/lib/" \; 2>/dev/null || true
          
          # Copy all version-specific library files (e.g., libm-2.35.a)
          find /usr/lib "$SYSTEM_LIB_DIR" -name "*-[0-9]*.[0-9]*.a" -exec cp {} "$SYSROOT_DIR/lib/" \; 2>/dev/null || true
          find /usr/lib "$SYSTEM_LIB_DIR" -name "*-[0-9]*.[0-9]*.so*" -exec cp -P {} "$SYSROOT_DIR/lib/" \; 2>/dev/null || true
          
          # Copy GCC runtime libraries if available
          echo "Copying GCC runtime libraries..."
          for lib_pattern in "libgcc_s.so*" "libstdc++.so*" "libstdc++.a" "libgfortran.so*" "libgfortran.a" \
                             "libgomp.so*" "libgomp.a" "libquadmath.so*" "libquadmath.a"; do
            find /usr/lib "$SYSTEM_LIB_DIR" -name "$lib_pattern" -exec cp -P {} "$SYSROOT_DIR/lib/" \; 2>/dev/null || true
          done
          
          # Copy dynamic linker and all its symlinks
          echo "Copying dynamic linker..."
          find /lib /lib64 -name "ld-linux*.so*" -exec cp -P {} "$SYSROOT_DIR/lib/" \; 2>/dev/null || true
          find /lib /lib64 -name "ld.so.1" -exec cp -P {} "$SYSROOT_DIR/lib/" \; 2>/dev/null || true
          find /lib /lib64 -name "ld64.so.1" -exec cp -P {} "$SYSROOT_DIR/lib/" \; 2>/dev/null || true
          
          # Architecture-specific dynamic linker patterns
          if [ "${{ matrix.arch }}" = "x86_64" ]; then
            find /lib* -name "ld-linux-x86-64.so*" -exec cp -P {} "$SYSROOT_DIR/lib/" \; 2>/dev/null || true
          elif [ "${{ matrix.arch }}" = "aarch64" ]; then
            find /lib* -name "ld-linux-aarch64.so*" -exec cp -P {} "$SYSROOT_DIR/lib/" \; 2>/dev/null || true
          fi
          
          # Show space usage analysis before copying headers
          echo "=== Space Usage Analysis ==="
          
          # Analyze source directories
          echo "Source directory sizes:"
          echo "  /usr/include: $(du -sh /usr/include 2>/dev/null | cut -f1 || echo 'N/A')"
          echo "  /usr/include/$MULTIARCH_DIR: $(du -sh /usr/include/$MULTIARCH_DIR 2>/dev/null | cut -f1 || echo 'N/A')"
          echo "  /lib: $(du -sh /lib 2>/dev/null | cut -f1 || echo 'N/A')"
          echo "  /usr/lib: $(du -sh /usr/lib 2>/dev/null | cut -f1 || echo 'N/A')"
          echo "  /usr/lib/$MULTIARCH_DIR: $(du -sh /usr/lib/$MULTIARCH_DIR 2>/dev/null | cut -f1 || echo 'N/A')"
          
          # Show current sysroot size
          CURRENT_SIZE=$(du -sh "$SYSROOT_DIR" 2>/dev/null | cut -f1 || echo '0')
          echo "Current sysroot size: $CURRENT_SIZE"
          
          # Count files in source directories
          echo "File counts in source directories:"
          echo "  /usr/include files: $(find /usr/include -type f 2>/dev/null | wc -l || echo '0')"
          echo "  /lib library files: $(find /lib -name '*.so*' -o -name '*.a' 2>/dev/null | wc -l || echo '0')"
          echo "  /usr/lib library files: $(find /usr/lib -name '*.so*' -o -name '*.a' 2>/dev/null | wc -l || echo '0')"
          
          # Copy system headers
          echo "Copying system headers..."
          if [ -d "/usr/include" ]; then
            cp -r /usr/include/* "$SYSROOT_DIR/usr/include/" 2>/dev/null || true
          fi
          
          # Copy architecture-specific headers
          if [ -d "/usr/include/$MULTIARCH_DIR" ]; then
            echo "Copying architecture-specific headers from /usr/include/$MULTIARCH_DIR"
            # Merge architecture-specific headers into main include directory
            cp -r /usr/include/$MULTIARCH_DIR/* "$SYSROOT_DIR/usr/include/" 2>/dev/null || true
            # Also keep the multiarch directory structure for compatibility
            cp -r /usr/include/$MULTIARCH_DIR "$SYSROOT_DIR/usr/include/" 2>/dev/null || true
          fi
          
          # Create lib64 symlink for x86_64
          if [ "${{ matrix.arch }}" = "x86_64" ]; then
            ln -sf lib "$SYSROOT_DIR/lib64"
          fi
          
          # Fix absolute symlinks to be relative within sysroot
          echo "Fixing absolute symlinks..."
          find "$SYSROOT_DIR" -type l | while read -r symlink; do
            target=$(readlink "$symlink")
            
            # Only process absolute symlinks
            if [[ "$target" = /* ]]; then
              symlink_dir=$(dirname "$symlink")
              symlink_name=$(basename "$symlink")
              
              echo "Processing absolute symlink: $symlink_name -> $target"
              
              # Check if target exists in our sysroot
              target_basename=$(basename "$target")
              sysroot_target=""
              
              # Look for the target file in our sysroot
              if [ -f "$SYSROOT_DIR/lib/$target_basename" ]; then
                sysroot_target="$SYSROOT_DIR/lib/$target_basename"
              elif [ -f "$SYSROOT_DIR/usr/lib/$target_basename" ]; then
                sysroot_target="$SYSROOT_DIR/usr/lib/$target_basename"
              fi
              
              if [ -n "$sysroot_target" ]; then
                # Calculate relative path from symlink to target
                rel_path=$(realpath --relative-to="$symlink_dir" "$sysroot_target")
                
                echo "  Updating: $symlink_name -> $rel_path"
                rm "$symlink"
                ln -sf "$rel_path" "$symlink"
              else
                echo "  Warning: Target $target_basename not found in sysroot"
                
                # Option: Copy the target file if it exists on the system
                if [ -f "$target" ]; then
                  echo "  Copying target file: $target -> $SYSROOT_DIR/lib/$target_basename"
                  cp -P "$target" "$SYSROOT_DIR/lib/$target_basename"
                  rm "$symlink"
                  ln -sf "$target_basename" "$symlink"
                else
                  echo "  Target file $target does not exist on system, removing broken symlink"
                  rm "$symlink"
                fi
              fi
            fi
          done
          
          # Create usage documentation
          cat > "$SYSROOT_DIR/README.md" << 'EOF'
          # glibc Sysroot Package
          
          This package contains glibc headers and libraries for use with GCC.
          
          ## Contents
          - `lib/`: C runtime objects (crt*.o), glibc libraries (static and dynamic)
          - `usr/include/`: System headers including architecture-specific headers
          - `usr/lib/`: Additional system libraries
          
          ## Usage with GCC
          
          ### Method 1: Use --sysroot flag
          ```bash
          gcc --sysroot=/path/to/glibc-sysroot-<arch> -o hello hello.c
          ```
          
          ### Method 2: Set environment variables
          ```bash
          export CPATH=/path/to/glibc-sysroot-<arch>/usr/include
          export LIBRARY_PATH=/path/to/glibc-sysroot-<arch>/lib
          gcc -o hello hello.c
          ```
          
          ### Method 3: Copy to system locations (if you have permissions)
          ```bash
          sudo cp -r lib/* /usr/local/lib/
          sudo cp -r usr/include/* /usr/local/include/
          gcc -o hello hello.c
          ```
          
          ## Static vs Dynamic Linking
          - For portable binaries: `gcc -static --sysroot=... -o hello hello.c`
          - For system binaries: `gcc --sysroot=... -o hello hello.c`
          
          This sysroot is compatible with the GCC build from the same architecture.
          EOF
          
          # Verify sysroot contents
          echo "=== Sysroot Contents ==="
          echo "Runtime objects:"
          ls -la "$SYSROOT_DIR/lib/" | grep "crt" || echo "No CRT files found"
          echo "All library files:"
          ls -la "$SYSROOT_DIR/lib/"
          echo "All header files:"
          ls -la "$SYSROOT_DIR/usr/include/"
          
          # Check for critical headers
          echo "=== Critical Headers Check ==="
          for header in "stdio.h" "stdlib.h" "bits/libc-header-start.h" "bits/wordsize.h" "gnu/stubs.h"; do
            if [ -f "$SYSROOT_DIR/usr/include/$header" ]; then
              echo "✅ Found $header"
            else
              echo "❌ Missing $header"
            fi
          done
          
          # Check for critical libraries
          echo "=== Critical Libraries Check ==="
          
          # Check static libraries
          echo "Static libraries:"
          for lib in "libc.a" "libm.a" "libc_nonshared.a"; do
            if find "$SYSROOT_DIR/lib/" -name "$lib" | grep -q .; then
              echo "✅ Found $lib"
            else
              echo "❌ Missing $lib"
            fi
          done
          
          # Check architecture-specific libraries
          echo "Architecture-specific libraries:"
          if find "$SYSROOT_DIR/lib/" -name "libmvec*" | grep -q .; then
            echo "✅ Found libmvec ($(find "$SYSROOT_DIR/lib/" -name "libmvec*" | wc -l) files)"
          else
            echo "❌ Missing libmvec (may not be available on ${{ matrix.arch }})"
          fi
          
          if [ "${{ matrix.arch }}" = "x86_64" ]; then
            if find "$SYSROOT_DIR/lib/" -name "libquadmath*" | grep -q .; then
              echo "✅ Found libquadmath (x86_64 specific)"
            else
              echo "❌ Missing libquadmath (x86_64 specific)"
            fi
          else
            echo "ℹ️  libquadmath not expected on ${{ matrix.arch }}"
          fi
          
          # Check shared libraries and symlinks
          echo "Shared libraries:"
          for lib in "libc.so.6" "libm.so.6"; do
            if find "$SYSROOT_DIR/lib/" -name "$lib" | grep -q .; then
              echo "✅ Found $lib"
            else
              echo "❌ Missing $lib"
            fi
          done
          
          # Check dynamic linker
          echo "Dynamic linker:"
          if [ "${{ matrix.arch }}" = "x86_64" ]; then
            if find "$SYSROOT_DIR/lib/" -name "ld-linux-x86-64.so*" | grep -q .; then
              echo "✅ Found ld-linux-x86-64.so*"
            else
              echo "❌ Missing ld-linux-x86-64.so*"
            fi
          elif [ "${{ matrix.arch }}" = "aarch64" ]; then
            if find "$SYSROOT_DIR/lib/" -name "ld-linux-aarch64.so*" | grep -q .; then
              echo "✅ Found ld-linux-aarch64.so*"
            else
              echo "❌ Missing ld-linux-aarch64.so*"
            fi
          fi
          
          # Check for version-specific files
          echo "Version-specific files:"
          VERSION_SPECIFIC_COUNT=$(find "$SYSROOT_DIR/lib/" -name "*-[0-9]*.[0-9]*.so" -o -name "*-[0-9]*.[0-9]*.a" | wc -l)
          echo "Found $VERSION_SPECIFIC_COUNT version-specific library files"
          
          # Check for symlinks
          echo "Symlinks:"
          SYMLINK_COUNT=$(find "$SYSROOT_DIR/lib/" -type l | wc -l)
          echo "Found $SYMLINK_COUNT symlinks"
          if [ "$SYMLINK_COUNT" -gt 0 ]; then
            echo "All symlinks:"
            find "$SYSROOT_DIR/lib/" -type l | while read link; do
              echo "  $(basename "$link") -> $(readlink "$link")"
            done
            
            # Check for remaining absolute symlinks
            echo "Symlink analysis:"
            ABSOLUTE_LINKS=$(find "$SYSROOT_DIR" -type l -exec readlink {} \; | grep "^/" | wc -l)
            RELATIVE_LINKS=$(find "$SYSROOT_DIR" -type l -exec readlink {} \; | grep -v "^/" | wc -l)
            echo "  Relative symlinks: $RELATIVE_LINKS"
            echo "  Absolute symlinks: $ABSOLUTE_LINKS"
            
            if [ "$ABSOLUTE_LINKS" -gt 0 ]; then
              echo "  Warning: Some absolute symlinks remain:"
              find "$SYSROOT_DIR" -type l | while read link; do
                target=$(readlink "$link")
                if [[ "$target" = /* ]]; then
                  echo "    $(basename "$link") -> $target"
                fi
              done
            else
              echo "  ✅ All symlinks are now relative"
            fi
          fi
          
          # Final space usage analysis
          echo "=== Final Sysroot Analysis ==="
          FINAL_SIZE=$(du -sh "$SYSROOT_DIR" 2>/dev/null | cut -f1 || echo '0')
          FINAL_SIZE_BYTES=$(du -sb "$SYSROOT_DIR" 2>/dev/null | cut -f1 || echo '0')
          echo "Final sysroot size: $FINAL_SIZE ($FINAL_SIZE_BYTES bytes)"
          
          echo "Breakdown by directory:"
          echo "  lib/: $(du -sh "$SYSROOT_DIR/lib" 2>/dev/null | cut -f1 || echo '0')"
          echo "  usr/include/: $(du -sh "$SYSROOT_DIR/usr/include" 2>/dev/null | cut -f1 || echo '0')"
          echo "  usr/lib/: $(du -sh "$SYSROOT_DIR/usr/lib" 2>/dev/null | cut -f1 || echo '0')"
          
          echo "File counts in sysroot:"
          echo "  Total files: $(find "$SYSROOT_DIR" -type f 2>/dev/null | wc -l || echo '0')"
          echo "  Library files (.so/.a): $(find "$SYSROOT_DIR" -name '*.so*' -o -name '*.a' 2>/dev/null | wc -l || echo '0')"
          echo "  Header files (.h): $(find "$SYSROOT_DIR" -name '*.h' 2>/dev/null | wc -l || echo '0')"
          echo "  Symlinks: $(find "$SYSROOT_DIR" -type l 2>/dev/null | wc -l || echo '0')"
          
          # Estimate what full directory inclusion would cost
          echo "=== Full Directory Inclusion Analysis ==="
          echo "If we included entire directories, additional space would be:"
          
          # Calculate what we'd get by including all of /lib
          ALL_LIB_SIZE=$(find /lib -name '*.so*' -o -name '*.a' -o -name 'ld*' 2>/dev/null | xargs du -sc 2>/dev/null | tail -1 | cut -f1 || echo '0')
          CURRENT_LIB_SIZE=$(find "$SYSROOT_DIR/lib" -type f 2>/dev/null | xargs du -sc 2>/dev/null | tail -1 | cut -f1 || echo '0')
          ADDITIONAL_LIB=$((ALL_LIB_SIZE - CURRENT_LIB_SIZE))
          echo "  All /lib libraries: +$(numfmt --to=iec $((ADDITIONAL_LIB * 1024)) 2>/dev/null || echo "${ADDITIONAL_LIB}K")"
          
          # Calculate what we'd get by including all of /usr/lib/$MULTIARCH_DIR
          if [ -d "/usr/lib/$MULTIARCH_DIR" ]; then
            ALL_MULTIARCH_SIZE=$(find "/usr/lib/$MULTIARCH_DIR" -name '*.so*' -o -name '*.a' 2>/dev/null | xargs du -sc 2>/dev/null | tail -1 | cut -f1 || echo '0')
            echo "  All /usr/lib/$MULTIARCH_DIR libraries: $(numfmt --to=iec $((ALL_MULTIARCH_SIZE * 1024)) 2>/dev/null || echo "${ALL_MULTIARCH_SIZE}K")"
          fi
          
          # Show compression ratio estimate
          echo "=== Compression Analysis ==="
          echo "Uncompressed sysroot: $FINAL_SIZE"
          
          # Create sysroot archive
          tar -czf "glibc-sysroot-${{ needs.get-version.outputs.exact_version }}-${{ matrix.arch }}.tar.gz" "$SYSROOT_DIR"
          
          # Show compressed size
          COMPRESSED_SIZE=$(ls -lh "glibc-sysroot-${{ needs.get-version.outputs.exact_version }}-${{ matrix.arch }}.tar.gz" | awk '{print $5}')
          COMPRESSED_BYTES=$(ls -l "glibc-sysroot-${{ needs.get-version.outputs.exact_version }}-${{ matrix.arch }}.tar.gz" | awk '{print $5}')
          COMPRESSION_RATIO=$(echo "scale=1; $COMPRESSED_BYTES * 100 / $FINAL_SIZE_BYTES" | bc -l 2>/dev/null || echo "N/A")
          
          echo "Compressed size: $COMPRESSED_SIZE (${COMPRESSION_RATIO}% of original)"
          echo "✅ Created glibc-sysroot-${{ needs.get-version.outputs.exact_version }}-${{ matrix.arch }}.tar.gz"

      - name: Verify static linking
        run: |
          cd build-gcc-${{ matrix.arch }}/install-root/opt/gcc-${{ needs.get-version.outputs.exact_version }}-${{ matrix.arch }}/bin
          echo "Checking static linking of key GCC tools..."
          
          # Check if binaries are statically linked (should show 'statically linked')
          for tool in gcc g++ gfortran; do
            if [ -f "$tool" ]; then
              echo "=== $tool ==="
              file "$tool"
              echo "Dynamic dependencies:"
              ldd "$tool" 2>/dev/null || echo "  (statically linked)"
              echo
            fi
          done

      - name: Build summary
        run: |
          echo "=== GCC Build Complete ==="
          if [ "${{ github.event.inputs.branch }}" != "main" ] && [ "${{ github.event.inputs.branch }}" != "" ]; then
            echo "ℹ️  Note: Built from branch '${{ github.event.inputs.branch }}' - no release will be created"
            echo "   Artifacts are available for download from this workflow run"
          else
            echo "✅ Built from main branch - release will be created with artifacts"
          fi

      - name: Create archive
        run: |
          cd build-gcc-${{ matrix.arch }}/install-root/opt
          tar -czf $GITHUB_WORKSPACE/gcc-${{ needs.get-version.outputs.exact_version }}-${{ matrix.arch }}.tar.gz gcc-${{ needs.get-version.outputs.exact_version }}-${{ matrix.arch }}

      - name: Upload GCC artifact
        uses: actions/upload-artifact@v4
        with:
          name: gcc-${{ needs.get-version.outputs.exact_version }}-${{ matrix.arch }}
          path: gcc-${{ needs.get-version.outputs.exact_version }}-${{ matrix.arch }}.tar.gz

      - name: Upload sysroot artifact
        uses: actions/upload-artifact@v4
        with:
          name: glibc-sysroot-${{ needs.get-version.outputs.exact_version }}-${{ matrix.arch }}
          path: glibc-sysroot-${{ needs.get-version.outputs.exact_version }}-${{ matrix.arch }}.tar.gz

  create-release:
    needs: [get-version, build-gcc]
    runs-on: ubuntu-latest
    if: github.event.inputs.branch == 'main' || github.event.inputs.branch == ''
    permissions:
      contents: write
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          ref: ${{ github.event.inputs.branch }}

      - name: Download all artifacts
        uses: actions/download-artifact@v4
        with:
          path: artifacts

      - name: List artifacts
        run: |
          echo "=== Artifact directory structure ==="
          find artifacts -type f -name "*.tar.gz" | sort
          echo "=== Detailed directory listing ==="
          ls -la artifacts/

      - name: Delete existing release if it exists
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          # Check if release exists and delete it
          if gh release view ${{ needs.get-version.outputs.exact_version }} >/dev/null 2>&1; then
            echo "Release ${{ needs.get-version.outputs.exact_version }} exists, deleting..."
            gh release delete ${{ needs.get-version.outputs.exact_version }} --yes
          else
            echo "Release ${{ needs.get-version.outputs.exact_version }} does not exist"
          fi

      - name: Create new release
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          # Create the release
          gh release create ${{ needs.get-version.outputs.exact_version }} \
            --title "GCC ${{ needs.get-version.outputs.exact_version }}" \
            --notes "GCC ${{ needs.get-version.outputs.exact_version }} builds for x86_64 and aarch64 architectures.

          Built from source with the following configuration:
          - Languages: C, C++, Fortran (bootstrap version)
          - Architectures: x86_64 (native), aarch64 (native ARM64)
          - Features: Static libraries, POSIX threads
          - Dependencies: Statically linked GMP ${{ env.GMP_VERSION }}, MPFR ${{ env.MPFR_VERSION }}, MPC ${{ env.MPC_VERSION }}, ISL ${{ env.ISL_VERSION }}
          - Type: Static bootstrap build suitable for compiling more advanced GCC versions
          - Build method: Native compilation with dependencies built from source
          - Optimization: Stripped static binaries for reduced download size
          - Compatibility: Fully self-contained - no external dependencies except glibc
          
          ## Files
          
          ### GCC Compiler
          - \`gcc-${{ needs.get-version.outputs.exact_version }}-x86_64.tar.gz\`: GCC build for x86_64 architecture
          - \`gcc-${{ needs.get-version.outputs.exact_version }}-aarch64.tar.gz\`: GCC build for aarch64 architecture
          
          ### glibc Sysroot (Runtime Libraries)
          - \`glibc-sysroot-${{ needs.get-version.outputs.exact_version }}-x86_64.tar.gz\`: glibc headers and libraries for x86_64
          - \`glibc-sysroot-${{ needs.get-version.outputs.exact_version }}-aarch64.tar.gz\`: glibc headers and libraries for aarch64
          
          ## Installation & Usage
          
          ### Option 1: GCC Only (requires system glibc)
          \`\`\`bash
          tar -xzf gcc-${{ needs.get-version.outputs.exact_version }}-<arch>.tar.gz
          export PATH=\$PWD/gcc-${{ needs.get-version.outputs.exact_version }}-<arch>/bin:\$PATH
          gcc -o hello hello.c  # Works if system has compatible glibc
          \`\`\`
          
          ### Option 2: GCC + Sysroot (self-contained, recommended)
          \`\`\`bash
          # Extract both packages
          tar -xzf gcc-${{ needs.get-version.outputs.exact_version }}-<arch>.tar.gz
          tar -xzf glibc-sysroot-${{ needs.get-version.outputs.exact_version }}-<arch>.tar.gz
          
          # Set up environment
          export PATH=\$PWD/gcc-${{ needs.get-version.outputs.exact_version }}-<arch>/bin:\$PATH
          export SYSROOT=\$PWD/glibc-sysroot-<arch>
          
          # Compile with sysroot
          gcc --sysroot=\$SYSROOT -o hello hello.c
          gcc --sysroot=\$SYSROOT -static -o hello_static hello.c  # Fully portable binary
          \`\`\`
          
          ### Option 3: Environment Variables
          \`\`\`bash
          export CPATH=\$PWD/glibc-sysroot-<arch>/usr/include
          export LIBRARY_PATH=\$PWD/glibc-sysroot-<arch>/lib
          gcc -o hello hello.c  # No --sysroot needed
          \`\`\`
          
          ## Using as Bootstrap Compiler
          This minimal build can be used to compile a more feature-rich GCC version with additional options like:
          - Go and JIT language support
          - Plugin support (\`--enable-plugin\`, \`--enable-host-shared\`)
          - Link-time optimization (\`--enable-lto\`)
          - Security hardening (\`--enable-default-pie\`, \`--enable-default-ssp\`)
          - Performance optimizations and debugging features" \
            artifacts/gcc-${{ needs.get-version.outputs.exact_version }}-x86_64/gcc-${{ needs.get-version.outputs.exact_version }}-x86_64.tar.gz \
            artifacts/gcc-${{ needs.get-version.outputs.exact_version }}-aarch64/gcc-${{ needs.get-version.outputs.exact_version }}-aarch64.tar.gz \
            artifacts/glibc-sysroot-${{ needs.get-version.outputs.exact_version }}-x86_64/glibc-sysroot-${{ needs.get-version.outputs.exact_version }}-x86_64.tar.gz \
            artifacts/glibc-sysroot-${{ needs.get-version.outputs.exact_version }}-aarch64/glibc-sysroot-${{ needs.get-version.outputs.exact_version }}-aarch64.tar.gz
