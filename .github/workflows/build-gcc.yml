name: Build GCC from Source

on:
  workflow_dispatch:
    inputs:
      version:
        description: 'GCC Version to build'
        required: true
        default: '15'
        type: choice
        options:
          - '15'
          - '14'
          - '13'
          - '12'
      branch:
        description: 'Branch to checkout for workflow'
        required: false
        default: 'main'
        type: string

env:
  # Version mappings - will be used to get exact versions
  GCC_15_VERSION: '15.1.0'
  GCC_14_VERSION: '14.3.0'
  GCC_13_VERSION: '13.3.0'
  GCC_12_VERSION: '12.4.0'

jobs:
  get-version:
    runs-on: ubuntu-latest
    outputs:
      exact_version: ${{ steps.set-version.outputs.exact_version }}
      major_version: ${{ steps.set-version.outputs.major_version }}
    steps:
      - name: Set exact version
        id: set-version
        run: |
          case "${{ github.event.inputs.version }}" in
            "15")
              echo "exact_version=${{ env.GCC_15_VERSION }}" >> $GITHUB_OUTPUT
              echo "major_version=15" >> $GITHUB_OUTPUT
              ;;
            "14")
              echo "exact_version=${{ env.GCC_14_VERSION }}" >> $GITHUB_OUTPUT
              echo "major_version=14" >> $GITHUB_OUTPUT
              ;;
            "13")
              echo "exact_version=${{ env.GCC_13_VERSION }}" >> $GITHUB_OUTPUT
              echo "major_version=13" >> $GITHUB_OUTPUT
              ;;
            "12")
              echo "exact_version=${{ env.GCC_12_VERSION }}" >> $GITHUB_OUTPUT
              echo "major_version=12" >> $GITHUB_OUTPUT
              ;;
            *)
              echo "Unsupported version: ${{ github.event.inputs.version }}"
              exit 1
              ;;
          esac

  build-gcc:
    needs: get-version
    timeout-minutes: 120
    strategy:
      matrix:
        include:
          - arch: x86_64
            runner: ubuntu-22.04
          - arch: aarch64
            runner: ubuntu-22.04-arm
    runs-on: ${{ matrix.runner }}
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          ref: ${{ github.event.inputs.branch }}

      - name: Set up build environment
        run: |
          sudo apt-get update
          sudo apt-get install -y \
            build-essential \
            libgmp-dev \
            libmpfr-dev \
            libmpc-dev \
            libisl-dev \
            zlib1g-dev \
            wget \
            tar \
            xz-utils \
            flex \
            bison \
            texinfo \
            python3 \
            make \
            patch
          
          # Verify static zlib library is available
          ls -la /usr/lib/*/libz.a || echo "Static zlib not found in expected location"
          find /usr -name "libz.a" 2>/dev/null || echo "Static zlib library not found"

      # No cross-compilation tools needed - using native ARM64 runner for aarch64

      - name: Download GCC source
        run: |
          # Try multiple mirrors for reliability
          wget -q https://mirror.csclub.uwaterloo.ca/gnu/gcc/gcc-${{ needs.get-version.outputs.exact_version }}/gcc-${{ needs.get-version.outputs.exact_version }}.tar.xz || \
          wget -q https://mirrors.kernel.org/gnu/gcc/gcc-${{ needs.get-version.outputs.exact_version }}/gcc-${{ needs.get-version.outputs.exact_version }}.tar.xz || \
          wget -q https://ftp.gnu.org/gnu/gcc/gcc-${{ needs.get-version.outputs.exact_version }}/gcc-${{ needs.get-version.outputs.exact_version }}.tar.xz
          tar -xf gcc-${{ needs.get-version.outputs.exact_version }}.tar.xz

      - name: Download prerequisites
        run: |
          cd gcc-${{ needs.get-version.outputs.exact_version }}
          ./contrib/download_prerequisites

      - name: Build glibc sysroot
        run: |
          # Create sysroot directory structure
          SYSROOT="/opt/gcc-${{ needs.get-version.outputs.exact_version }}-${{ matrix.arch }}/sysroot"
          mkdir -p "$SYSROOT"/{lib,lib64,usr/lib,usr/include}
          
          # Get the system's multiarch directory
          MULTIARCH_DIR=$(gcc -print-multiarch 2>/dev/null || echo "$(uname -m)-linux-gnu")
          SYSTEM_LIB_DIR="/usr/lib/$MULTIARCH_DIR"
          
          echo "Building glibc sysroot for ${{ matrix.arch }}"
          echo "System multiarch directory: $MULTIARCH_DIR"
          echo "System lib directory: $SYSTEM_LIB_DIR"
          
          # Copy glibc runtime libraries and startup files
          echo "Copying glibc runtime libraries..."
          
          # Copy C runtime startup files (crt*.o)
          if [ -d "$SYSTEM_LIB_DIR" ]; then
            find "$SYSTEM_LIB_DIR" -name "crt*.o" -exec cp {} "$SYSROOT/lib/" \; 2>/dev/null || true
            find /usr/lib -name "crt*.o" -exec cp {} "$SYSROOT/lib/" \; 2>/dev/null || true
          fi
          
          # Copy essential glibc libraries
          for lib in libc.so.6 libm.so.6 libpthread.so.0 libdl.so.2 libresolv.so.2 librt.so.1 libutil.so.1; do
            find /lib /usr/lib -name "$lib" -exec cp {} "$SYSROOT/lib/" \; 2>/dev/null || true
          done
          
          # Copy static libraries if available
          for lib in libc.a libm.a libpthread.a libdl.a libresolv.a librt.a libutil.a; do
            find /usr/lib -name "$lib" -exec cp {} "$SYSROOT/lib/" \; 2>/dev/null || true
          done
          
          # Copy ld-linux.so (dynamic linker)
          find /lib /lib64 -name "ld-linux*.so*" -exec cp {} "$SYSROOT/lib/" \; 2>/dev/null || true
          find /lib /lib64 -name "ld.so.1" -exec cp {} "$SYSROOT/lib/" \; 2>/dev/null || true
          
          # Copy system headers
          echo "Copying system headers..."
          if [ -d "/usr/include" ]; then
            cp -r /usr/include/* "$SYSROOT/usr/include/" 2>/dev/null || true
          fi
          
          # Create lib64 symlink for x86_64
          if [ "${{ matrix.arch }}" = "x86_64" ]; then
            ln -sf lib "$SYSROOT/lib64"
          fi
          
          # Verify sysroot contents
          echo "Sysroot contents:"
          ls -la "$SYSROOT"/lib/ | head -20
          echo "Headers available:"
          ls -la "$SYSROOT"/usr/include/ | head -10

      - name: Configure build
        run: |
          mkdir -p build-gcc-${{ matrix.arch }}
          cd build-gcc-${{ matrix.arch }}
          
          # Set up sysroot path
          SYSROOT="/opt/gcc-${{ needs.get-version.outputs.exact_version }}-${{ matrix.arch }}/sysroot"
          
          # Native build configuration with glibc sysroot
          # Build static GCC binaries but with glibc sysroot for target compilation
          # This creates a GCC that produces glibc binaries but runs in busybox
          CFLAGS="-O2" CXXFLAGS="-O2" \
          LDFLAGS="-static" \
          LIBS="-lz" \
          ../gcc-${{ needs.get-version.outputs.exact_version }}/configure \
            --prefix=/opt/gcc-${{ needs.get-version.outputs.exact_version }}-${{ matrix.arch }} \
            --with-sysroot="$SYSROOT" \
            --with-native-system-header-dir=/usr/include \
            --enable-languages=c,c++,fortran \
            --disable-multilib \
            --enable-threads=posix \
            --disable-shared \
            --enable-static \
            --with-system-zlib \
            --disable-bootstrap \
            --enable-__cxa_atexit \
            --enable-gnu-unique-object \
            --with-glibc-version=2.35

      - name: Build GCC
        run: |
          cd build-gcc-${{ matrix.arch }}
          make -j$(nproc)

      - name: Install GCC
        run: |
          cd build-gcc-${{ matrix.arch }}
          sudo make install-strip DESTDIR=$PWD/install-root

      - name: Verify static linking
        run: |
          cd build-gcc-${{ matrix.arch }}/install-root/opt/gcc-${{ needs.get-version.outputs.exact_version }}-${{ matrix.arch }}/bin
          echo "Checking static linking of key GCC tools..."
          
          # Check if binaries are statically linked (should show 'statically linked')
          for tool in gcc g++ gfortran; do
            if [ -f "$tool" ]; then
              echo "=== $tool ==="
              file "$tool"
              echo "Dynamic dependencies:"
              ldd "$tool" 2>/dev/null || echo "  (statically linked)"
              echo
            fi
          done

      - name: Test GCC compilation and linking
        run: |
          cd build-gcc-${{ matrix.arch }}/install-root/opt/gcc-${{ needs.get-version.outputs.exact_version }}-${{ matrix.arch }}
          
          # Set up environment for testing
          export PATH="$PWD/bin:$PATH"
          
          echo "=== Testing GCC Installation ==="
          echo "GCC version:"
          ./bin/gcc --version
          
          echo "GCC search paths:"
          ./bin/gcc -print-search-dirs
          
          echo "Sysroot:"
          ./bin/gcc -print-sysroot
          
          echo "Available GCC tools:"
          ls -la bin/
          
          # Test 1: Simple program without libc functions
          cat > test_basic.c << 'EOF'
          int main() {
              return 42;
          }
          EOF
          
          echo "=== Testing basic C compilation ==="
          if ./bin/gcc -v -o test_basic test_basic.c 2>&1; then
            echo "✅ SUCCESS: Basic C program compiled successfully"
            if ./test_basic; then
              echo "✅ SUCCESS: Basic C program executed successfully"
            else
              echo "⚠️  Program compiled but execution failed (may need runtime libs)"
            fi
          else
            echo "❌ ERROR: Basic C program compilation failed"
            exit 1
          fi
          
          # Test 2: Program with standard library functions
          cat > test_stdlib.c << 'EOF'
          #include <stdio.h>
          #include <stdlib.h>
          
          int main() {
              printf("Hello from glibc-based GCC!\n");
              void *ptr = malloc(100);
              if (ptr) {
                  printf("Memory allocation successful\n");
                  free(ptr);
              }
              return 0;
          }
          EOF
          
          echo "=== Testing glibc compilation ==="
          if ./bin/gcc -v -o test_stdlib test_stdlib.c 2>&1; then
            echo "✅ SUCCESS: glibc program compiled successfully"
            echo "Program uses glibc and should work on glibc systems"
          else
            echo "❌ ERROR: glibc program compilation failed"
            echo "Checking sysroot contents..."
            ls -la sysroot/lib/ | head -10
            exit 1
          fi
          
          # Test 3: Static linking test
          echo "=== Testing static linking ==="
          if ./bin/gcc -static -v -o test_static test_stdlib.c 2>&1; then
            echo "✅ SUCCESS: Static glibc program compiled successfully"
            echo "This creates a fully standalone binary"
          else
            echo "⚠️  WARNING: Static linking failed (may need static glibc libraries)"
          fi
          
          echo "=== GCC Build Complete ==="
          echo "This GCC build produces glibc binaries and can run in busybox environments"
          echo ""
          if [ "${{ github.event.inputs.branch }}" != "main" ] && [ "${{ github.event.inputs.branch }}" != "" ]; then
            echo "ℹ️  Note: Built from branch '${{ github.event.inputs.branch }}' - no release will be created"
            echo "   Artifacts are available for download from this workflow run"
          else
            echo "✅ Built from main branch - release will be created with artifacts"
          fi

      - name: Create archive
        run: |
          cd build-gcc-${{ matrix.arch }}/install-root/opt
          tar -czf $GITHUB_WORKSPACE/gcc-${{ needs.get-version.outputs.exact_version }}-${{ matrix.arch }}.tar.gz gcc-${{ needs.get-version.outputs.exact_version }}-${{ matrix.arch }}

      - name: Upload artifact
        uses: actions/upload-artifact@v4
        with:
          name: gcc-${{ needs.get-version.outputs.exact_version }}-${{ matrix.arch }}
          path: gcc-${{ needs.get-version.outputs.exact_version }}-${{ matrix.arch }}.tar.gz

  create-release:
    needs: [get-version, build-gcc]
    runs-on: ubuntu-latest
    if: github.event.inputs.branch == 'main' || github.event.inputs.branch == ''
    permissions:
      contents: write
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          ref: ${{ github.event.inputs.branch }}

      - name: Download all artifacts
        uses: actions/download-artifact@v4
        with:
          path: artifacts

      - name: List artifacts
        run: |
          find artifacts -type f -name "*.tar.gz" | sort

      - name: Delete existing release if it exists
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          # Check if release exists and delete it
          if gh release view ${{ needs.get-version.outputs.exact_version }} >/dev/null 2>&1; then
            echo "Release ${{ needs.get-version.outputs.exact_version }} exists, deleting..."
            gh release delete ${{ needs.get-version.outputs.exact_version }} --yes
          else
            echo "Release ${{ needs.get-version.outputs.exact_version }} does not exist"
          fi

      - name: Create new release
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          # Create the release
          gh release create ${{ needs.get-version.outputs.exact_version }} \
            --title "GCC ${{ needs.get-version.outputs.exact_version }}" \
            --notes "GCC ${{ needs.get-version.outputs.exact_version }} builds for x86_64 and aarch64 architectures.

          Built from source with the following configuration:
          - Languages: C, C++, Fortran
          - Architectures: x86_64 (native), aarch64 (native ARM64)
          - Features: Static libraries, POSIX threads, glibc sysroot
          - Type: GCC compiler with bundled glibc runtime libraries
          - Build method: Native compilation with glibc sysroot
          - Optimization: Stripped static binaries for reduced download size
          - Compatibility: Statically linked GCC binaries that run in busybox
          - Target binaries: Produces glibc-linked executables
          
          ## Files
          - \`gcc-${{ needs.get-version.outputs.exact_version }}-x86_64.tar.gz\`: GCC build for x86_64 architecture
          - \`gcc-${{ needs.get-version.outputs.exact_version }}-aarch64.tar.gz\`: GCC build for aarch64 architecture
          
          ## Installation
          Extract the appropriate archive and add the \`bin\` directory to your PATH:
          \`\`\`bash
          tar -xzf gcc-${{ needs.get-version.outputs.exact_version }}-<arch>.tar.gz
          export PATH=\$PWD/gcc-${{ needs.get-version.outputs.exact_version }}-<arch>/bin:\$PATH
          \`\`\`
          
          ## Key Features for Busybox Environments
          This GCC build is specifically designed for **busybox environments** with bundled glibc runtime libraries.
          
          **What this provides:**
          - ✅ **Self-contained**: Includes glibc headers and runtime libraries in sysroot
          - ✅ **Busybox compatible**: GCC binaries are statically linked and run in minimal environments
          - ✅ **glibc target**: Produces binaries that link against glibc (not musl)
          - ✅ **Complete toolchain**: Ready to compile standard C/C++ programs
          - ✅ **No external dependencies**: Works without installing additional packages
          
          ## Usage in Busybox Environment
          \`\`\`bash
          # Extract GCC in busybox environment
          tar -xzf gcc-${{ needs.get-version.outputs.exact_version }}-<arch>.tar.gz
          export PATH=\$PWD/gcc-${{ needs.get-version.outputs.exact_version }}-<arch>/bin:\$PATH
          
          # Compile programs directly - no additional setup needed
          gcc -o hello hello.c
          g++ -o hello_cpp hello.cpp
          
          # For fully static binaries (recommended for busybox)
          gcc -static -o hello_static hello.c
          \`\`\`
          
          ## What Makes This Different
          - **Bundled sysroot**: Contains glibc headers and libraries
          - **Static GCC**: Compiler itself has no runtime dependencies
          - **glibc compatibility**: Target programs use standard glibc, not musl
          - **Busybox ready**: Tested to work in minimal Linux environments
          
          ## Using as Bootstrap Compiler
          This complete build can also be used to compile more advanced GCC versions with additional options like:
          - Go and JIT language support
          - Plugin support (\`--enable-plugin\`, \`--enable-host-shared\`)
          - Link-time optimization (\`--enable-lto\`)
          - Security hardening (\`--enable-default-pie\`, \`--enable-default-ssp\`)
          - Performance optimizations and debugging features" \
            artifacts/gcc-${{ needs.get-version.outputs.exact_version }}-x86_64/gcc-${{ needs.get-version.outputs.exact_version }}-x86_64.tar.gz \
            artifacts/gcc-${{ needs.get-version.outputs.exact_version }}-aarch64/gcc-${{ needs.get-version.outputs.exact_version }}-aarch64.tar.gz